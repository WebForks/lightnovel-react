{"ast":null,"code":"/**\r\n * Build a query header for query/mutation queries with object\r\n * values.\r\n * @param {String} queryType - The type of query (ie: query or mutation)\r\n * @param {String} queryTarget - What query object is it? (SaveMediaListEntry or Media)\r\n * @param {Object} object - Object of input values to use in the header.\r\n */\nconst headerBuilder = function (queryType, queryTarget, object) {\n  let query = `${queryType} { ${queryTarget} (`;\n  const keys = Object.keys(object);\n  const values = Object.values(object);\n  keys.forEach((key, value) => {\n    if (key === \"startedAt\" || key === \"completedAt\") {\n      if (typeof values[value] !== \"object\") {\n        throw new Error(\"Date keys are not objects!\");\n      }\n      query += key + \": \" + JSON.stringify(values[value]).replace(/\"/g, \"\");\n      if (value + 1 !== keys.length) {\n        query += \", \";\n      }\n      return;\n    }\n    if (typeof values[value] === \"object\") {\n      throw new Error(\"Provided object has a nested value!\");\n    }\n    query += key + \": \" + values[value];\n    if (value + 1 !== keys.length) {\n      query += \", \";\n    }\n  });\n  return query + \") {\";\n};\nmodule.exports = headerBuilder;","map":{"version":3,"names":["headerBuilder","queryType","queryTarget","object","query","keys","Object","values","forEach","key","value","Error","JSON","stringify","replace","length","module","exports"],"sources":["C:/Users/Ethan Liu/Desktop/repos/lightnovel-react/node_modules/anilist-node/lib/utils/headerBuilder.js"],"sourcesContent":["/**\r\n * Build a query header for query/mutation queries with object\r\n * values.\r\n * @param {String} queryType - The type of query (ie: query or mutation)\r\n * @param {String} queryTarget - What query object is it? (SaveMediaListEntry or Media)\r\n * @param {Object} object - Object of input values to use in the header.\r\n */\r\nconst headerBuilder = function (queryType, queryTarget, object) {\r\n\tlet query = `${queryType} { ${queryTarget} (`;\r\n\r\n\tconst keys = Object.keys(object);\r\n\tconst values = Object.values(object);\r\n\r\n\tkeys.forEach((key, value) => {\r\n\t\tif (key === \"startedAt\" || key === \"completedAt\") {\r\n\t\t\tif (typeof values[value] !== \"object\") {\r\n\t\t\t\tthrow new Error(\"Date keys are not objects!\");\r\n\t\t\t}\r\n\r\n\t\t\tquery += key + \": \" + JSON.stringify(values[value]).replace(/\"/g, \"\");\r\n\t\t\tif (value + 1 !== keys.length) {\r\n\t\t\t\tquery += \", \";\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (typeof values[value] === \"object\") {\r\n\t\t\tthrow new Error(\"Provided object has a nested value!\");\r\n\t\t}\r\n\r\n\t\tquery += key + \": \" + values[value];\r\n\t\tif (value + 1 !== keys.length) {\r\n\t\t\tquery += \", \";\r\n\t\t}\r\n\t});\r\n\r\n\treturn query + \") {\";\r\n};\r\n\r\nmodule.exports = headerBuilder;\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMA,aAAa,GAAG,UAAUC,SAAS,EAAEC,WAAW,EAAEC,MAAM,EAAE;EAC/D,IAAIC,KAAK,GAAI,GAAEH,SAAU,MAAKC,WAAY,IAAG;EAE7C,MAAMG,IAAI,GAAGC,MAAM,CAACD,IAAI,CAACF,MAAM,CAAC;EAChC,MAAMI,MAAM,GAAGD,MAAM,CAACC,MAAM,CAACJ,MAAM,CAAC;EAEpCE,IAAI,CAACG,OAAO,CAAC,CAACC,GAAG,EAAEC,KAAK,KAAK;IAC5B,IAAID,GAAG,KAAK,WAAW,IAAIA,GAAG,KAAK,aAAa,EAAE;MACjD,IAAI,OAAOF,MAAM,CAACG,KAAK,CAAC,KAAK,QAAQ,EAAE;QACtC,MAAM,IAAIC,KAAK,CAAC,4BAA4B,CAAC;MAC9C;MAEAP,KAAK,IAAIK,GAAG,GAAG,IAAI,GAAGG,IAAI,CAACC,SAAS,CAACN,MAAM,CAACG,KAAK,CAAC,CAAC,CAACI,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC;MACrE,IAAIJ,KAAK,GAAG,CAAC,KAAKL,IAAI,CAACU,MAAM,EAAE;QAC9BX,KAAK,IAAI,IAAI;MACd;MACA;IACD;IAEA,IAAI,OAAOG,MAAM,CAACG,KAAK,CAAC,KAAK,QAAQ,EAAE;MACtC,MAAM,IAAIC,KAAK,CAAC,qCAAqC,CAAC;IACvD;IAEAP,KAAK,IAAIK,GAAG,GAAG,IAAI,GAAGF,MAAM,CAACG,KAAK,CAAC;IACnC,IAAIA,KAAK,GAAG,CAAC,KAAKL,IAAI,CAACU,MAAM,EAAE;MAC9BX,KAAK,IAAI,IAAI;IACd;EACD,CAAC,CAAC;EAEF,OAAOA,KAAK,GAAG,KAAK;AACrB,CAAC;AAEDY,MAAM,CAACC,OAAO,GAAGjB,aAAa"},"metadata":{},"sourceType":"script","externalDependencies":[]}