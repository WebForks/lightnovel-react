{"ast":null,"code":"const mediaFilterType = require(\"../types/mediaFilterTypes\");\nconst activityFilterType = require(\"../types/activityFilterTypes\");\n\n/**\r\n * Validates the filter object for searching.\r\n * @private\r\n * @param {String} type The type of query that the filter would be applied to.\r\n * @param {Object} filterObj A key/value paired filter object.\r\n * @returns Will throw an error if the filter object is bad (ie: Non-existent key or incorrect value type).\r\n * Returns nothing upon success.\r\n */\nconst validateFilters = function (type, filterObj) {\n  const filterKeys = Object.keys(filterObj);\n  let filterTest;\n  if (type === \"activity\") {\n    filterTest = activityFilterType;\n  }\n  if (type === \"anime\" || type === \"manga\") {\n    filterTest = mediaFilterType;\n  }\n  if (!filterTest) {\n    throw new Error(`Filter type not recognized by internal function. Bad type: ${type}.`);\n  }\n  for (let x = 0; x < filterKeys.length; x++) {\n    let myKey = filterKeys[x];\n    let myValue = filterObj[myKey];\n    let filterType = filterTest[myKey];\n    if (!filterType) {\n      throw new Error(`Filter key not recognized. Bad key: ${myKey}.`);\n    }\n    if (myValue instanceof Array) {\n      let typeDef = typeof filterType[0];\n      myValue.forEach(value => {\n        if (typeof value !== typeDef) {\n          throw new Error(`Value (${value}) type does not match filter type in array key (${myKey})!`);\n        }\n      });\n      continue;\n    }\n    if (typeof myValue !== filterType) {\n      throw new Error(`Value (${myValue}) type does not match filter type in key (${myKey})!`);\n    }\n  }\n};\n\n/**\r\n * Generate a query header with filter options.\r\n * @private\r\n * @param {String} searchType The search type to build the query with\r\n * @param {Object} filterObj A simple key-value pair object for setting filters.\r\n * @returns {String} Returns the query header if the filter is valid. Else, it will throw an error.\r\n */\nconst filterBuilder = function (searchType) {\n  let filterObj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  if (filterObj) {\n    validateFilters(searchType, filterObj);\n  }\n  let baseQuery = `query ($page: Int, $perPage: Int, $search: String) {\n        Page (page: $page, perPage: $perPage) { pageInfo { total currentPage lastPage hasNextPage perPage } `;\n  if (searchType === \"activity\") {\n    baseQuery = `query ($page: Int, $perPage: Int, $id: Int) {\n            Page (page: $page, perPage: $perPage) { pageInfo { total currentPage lastPage hasNextPage perPage } \n            activities (id: $id`;\n  }\n  if (searchType === \"anime\") {\n    baseQuery += \"media (type: ANIME, search: $search\";\n  }\n  if (searchType === \"manga\") {\n    baseQuery += \"media (type: MANGA, search: $search\";\n  }\n  if (filterObj) {\n    let filterKeys = Object.keys(filterObj);\n    for (let x = 0; x < filterKeys.length; x++) {\n      let filterValue = filterObj[filterKeys[x]];\n      if (filterValue instanceof Array) {\n        filterValue = `[${filterValue.join(\", \")}]`;\n      }\n      baseQuery += `, ${filterKeys[x]}: ${filterValue}`;\n    }\n  }\n  return `${baseQuery}) {`;\n};\nmodule.exports = filterBuilder;","map":{"version":3,"names":["mediaFilterType","require","activityFilterType","validateFilters","type","filterObj","filterKeys","Object","keys","filterTest","Error","x","length","myKey","myValue","filterType","Array","typeDef","forEach","value","filterBuilder","searchType","baseQuery","filterValue","join","module","exports"],"sources":["C:/Users/Ethan Liu/Desktop/repos/lightnovel-react/node_modules/anilist-node/lib/utils/filters.js"],"sourcesContent":["const mediaFilterType = require(\"../types/mediaFilterTypes\");\r\nconst activityFilterType = require(\"../types/activityFilterTypes\");\r\n\r\n/**\r\n * Validates the filter object for searching.\r\n * @private\r\n * @param {String} type The type of query that the filter would be applied to.\r\n * @param {Object} filterObj A key/value paired filter object.\r\n * @returns Will throw an error if the filter object is bad (ie: Non-existent key or incorrect value type).\r\n * Returns nothing upon success.\r\n */\r\nconst validateFilters = function(type, filterObj) {\r\n    const filterKeys = Object.keys(filterObj);\r\n    let filterTest;\r\n\r\n    if (type === \"activity\") {\r\n        filterTest = activityFilterType;\r\n    }\r\n    if (type === \"anime\" || type === \"manga\") {\r\n        filterTest = mediaFilterType;\r\n    }\r\n\r\n    if (!filterTest) { throw new Error(`Filter type not recognized by internal function. Bad type: ${type}.`); }\r\n\r\n    for (let x = 0; x < filterKeys.length; x++) {\r\n        let myKey = filterKeys[x];\r\n        let myValue = filterObj[myKey];\r\n        let filterType = filterTest[myKey];\r\n\r\n        if (!filterType) { throw new Error(`Filter key not recognized. Bad key: ${myKey}.`); }\r\n\r\n        if (myValue instanceof Array) {\r\n            let typeDef = typeof filterType[0];\r\n            myValue.forEach(value => {\r\n                if (typeof value !== typeDef) {\r\n                    throw new Error(`Value (${value}) type does not match filter type in array key (${myKey})!`); \r\n                }\r\n            });\r\n\r\n            continue;\r\n        } \r\n        \r\n        if (typeof myValue !== filterType) {\r\n            throw new Error(`Value (${myValue}) type does not match filter type in key (${myKey})!`);\r\n        }        \r\n    }\r\n};\r\n\r\n/**\r\n * Generate a query header with filter options.\r\n * @private\r\n * @param {String} searchType The search type to build the query with\r\n * @param {Object} filterObj A simple key-value pair object for setting filters.\r\n * @returns {String} Returns the query header if the filter is valid. Else, it will throw an error.\r\n */\r\nconst filterBuilder = function(searchType, filterObj=null) {\r\n    if (filterObj) { validateFilters(searchType, filterObj); }\r\n\r\n    let baseQuery = `query ($page: Int, $perPage: Int, $search: String) {\r\n        Page (page: $page, perPage: $perPage) { pageInfo { total currentPage lastPage hasNextPage perPage } `;\r\n\r\n    if (searchType === \"activity\") {\r\n        baseQuery = `query ($page: Int, $perPage: Int, $id: Int) {\r\n            Page (page: $page, perPage: $perPage) { pageInfo { total currentPage lastPage hasNextPage perPage } \r\n            activities (id: $id`;\r\n    }\r\n    if (searchType === \"anime\") {\r\n        baseQuery += \"media (type: ANIME, search: $search\";\r\n    }\r\n    if (searchType === \"manga\") {\r\n        baseQuery += \"media (type: MANGA, search: $search\";\r\n    }\r\n\r\n    if (filterObj) {\r\n        let filterKeys = Object.keys(filterObj);\r\n    \r\n        for (let x = 0; x < filterKeys.length; x++) {\r\n            let filterValue = filterObj[filterKeys[x]];\r\n\r\n            if (filterValue instanceof Array) {\r\n                filterValue = `[${filterValue.join(\", \")}]`;\r\n            }\r\n\r\n            baseQuery += `, ${filterKeys[x]}: ${filterValue}`; \r\n        }\r\n    }\r\n\r\n    return `${baseQuery}) {`;\r\n};\r\n\r\nmodule.exports = filterBuilder;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}