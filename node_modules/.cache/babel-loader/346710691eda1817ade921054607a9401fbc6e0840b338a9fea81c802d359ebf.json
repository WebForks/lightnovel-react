{"ast":null,"code":"const activity = require(\"./activity\"),\n  lists = require(\"./lists\"),\n  media = require(\"./media\"),\n  people = require(\"./people\"),\n  recommendation = require(\"./recommendation\"),\n  searchEntry = require(\"./search\"),\n  Thread = require(\"./thread\"),\n  User = require(\"./user\"),\n  util = require(\"./utilities\");\n\n/**\r\n * The main class for AniList-Node\r\n * @since 1.0.0\r\n */\nclass AniList {\n  /**\r\n   * @constructor\r\n   * @param {String} [accessKey] - The AniList API token. If no key is provided,\r\n   *      the user will not be able to access private information such as\r\n   *      the authorized user's profile (if set to private).\r\n   * @param {InitOptions} [options] - Optional options to use when getting info from AniList\r\n   */\n  constructor(accessKey) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!accessKey) {\n      accessKey = null;\n    }\n    if (options.timeout) {\n      if (typeof options.timeout !== \"number\") throw new TypeError(\"ERROR: 'options.timeout' should be a number\");\n    } else {\n      options.timeout = 15000;\n    }\n\n    // Import utilities for the classes.\n    this.__util = new util(accessKey, options);\n\n    /**\r\n     * @augments User\r\n     * @see {@Link AniList.User}\r\n     * @since 1.0.0\r\n     */\n    this.user = new User(this.__util);\n\n    /**\r\n     * @augments lists\r\n     * @see {@Link AniList.Lists}\r\n     * @since 1.1.0\r\n     */\n    this.lists = new lists(this.__util);\n\n    /**\r\n     * @augments media\r\n     * @see {@Link AniList.Media}\r\n     * @since 1.0.0\r\n     */\n    this.media = new media(this.__util);\n\n    /**\r\n     * @augments people\r\n     * @see {@Link AniList.People}\r\n     * @since 1.0.0\r\n     */\n    this.people = new people(this.__util);\n\n    /**\r\n     * @augments Activity\r\n     * @see {@Link AniList.Activity}\r\n     * @since 1.7.0\r\n     */\n    this.activity = new activity(this.__util);\n\n    /**\r\n     * @augments Search\r\n     * @see {@Link AniList.Search}\r\n     * @since 1.7.0\r\n     */\n    this.searchEntry = new searchEntry(this.__util);\n\n    /**\r\n     * @augments Recommendation\r\n     * @see {@Link AniList.Recommendation}\r\n     * @since 1.8.0\r\n     */\n    this.recommendation = new recommendation(this.__util);\n\n    /**\r\n     * @augments Thread\r\n     * @see {@Link AniList.Thread}\r\n     * @since 1.11.0\r\n     */\n    this.thread = new Thread(this.__util);\n  }\n\n  /**\r\n   * Grabs data on a studio\r\n   * @param {String | Number} studio - The studio ID or name on AniList.\r\n   * @return { StudioEntry }\r\n   * @since 1.0.0\r\n   */\n  studio(studio) {\n    const queryVars = this.__util.generateQueryHeaders(\"Studio\", studio);\n    return this.__util.send(queryVars[1] + `id name isAnimationStudio siteUrl isFavourite favourites \n            media { nodes { id title { romaji english native userPreferred } } } } }`, queryVars[0]);\n  }\n\n  /**\r\n   * [Requires Login] Favourite/Unfavourite a studio\r\n   * @param {Number} id - Required. The ID tied to the AniList entry.\r\n   * @returns {Boolean} Returns true if added, false otherwise.\r\n   * @since 1.12.0\r\n   */\n  async favouriteStudio(id) {\n    if (!id || typeof id !== \"number\") {\n      throw new Error(\"AniList ID is not provided!\");\n    }\n    const data = await this.util.send(`mutation ($studioID: Int) {\n\t\t\t\tToggleFavourite(studioId: $studioID) {\n\t\t\t\t\tstudios (page: 1, perPage: 25) {\n\t\t\t\t\tnodes { id }\n\t\t\t} } }`, {\n      studioID: id\n    });\n    return data.ToggleFavourite.studios.nodes.some(e => {\n      if (e.id === id) {\n        return true;\n      }\n    });\n  }\n\n  /**\r\n   * Searches AniList based on a specific term.\r\n   * @param {String} type - Required. Either anime, manga, character, staff, studio, or user.\r\n   * @param {String} term - Required. The term to lookup. (ie: \"Honzuki no Gekokujou\" or \"Butterstroke\")\r\n   * @param {Number} page - Which page of the results to look at. Will default to 1 if not provided.\r\n   * @param {Number} amount - The amount of results per page. AniList will cap this at 25 and function will default to 5 if not provided.\r\n   * @return { SearchEntry }\r\n   * @since 1.0.0\r\n   * @deprecated Please use {@link AniList.Search} class via `AniList.searchEntry` for updated searching. {@link AniList.Search} will replace\r\n   * this function in the next major update (v2.0.0).\r\n   */\n  search(type, term) {\n    let page = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    let amount = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 5;\n    if (!type) {\n      throw new Error(\"Type of search not defined!\");\n    } else if (!term) {\n      throw new Error(\"Search term was not provided!\");\n    }\n\n    //Validate all type conditions.\n    if (typeof type !== \"string\") {\n      throw new Error(\"Type is not a string.\");\n    }\n    if (typeof term !== \"string\") {\n      throw new Error(\"Term is not a string\");\n    }\n    if (typeof page !== \"number\") {\n      throw new Error(\"Page number is not a number\");\n    }\n    if (typeof amount !== \"number\") {\n      throw new Error(\"Amount is not a number\");\n    }\n    const search = {\n      anime: \"media (type: ANIME, search: $search) { id title { romaji english native userPreferred } }\",\n      manga: \"media (type: MANGA, search: $search) { id title { romaji english native userPreferred } }\",\n      char: \"characters (search: $search) { id name { english: full } }\",\n      staff: \"staff (search: $search) { id name { english: full } }\",\n      studio: \"studios (search: $search) { id name }\",\n      user: \"users (search: $search) { id name }\"\n    };\n    let query = search[type.toLowerCase()];\n    if (!query) {\n      throw new Error(\"Type not supported.\");\n    }\n    return this.__util.send(`query ($page: Int, $perPage: Int, $search: String) {\n        Page (page: $page, perPage: $perPage) { pageInfo { total currentPage lastPage hasNextPage perPage } ${query} } }`, {\n      search: term,\n      page: page,\n      perPage: amount\n    });\n  }\n\n  /**\r\n   * Grabs all possible genres\r\n   * @return { String[] }\r\n   * @since 1.12.0\r\n   */\n  genres() {\n    return this.__util.send(\"query { GenreCollection }\", null).then(data => {\n      return data.GenreCollection;\n    });\n  }\n\n  /**\r\n   * Grabs all possible media tags\r\n   * @return { MediaTag[] }\r\n   * @since 1.12.0\r\n   */\n  mediaTags() {\n    return this.__util.send(`query { MediaTagCollection {\n\t\t\t\tid name description category isAdult\n\t\t\t} }`, null).then(data => {\n      return data.MediaTagCollection;\n    });\n  }\n}\nmodule.exports = AniList;","map":{"version":3,"names":["activity","require","lists","media","people","recommendation","searchEntry","Thread","User","util","AniList","constructor","accessKey","options","timeout","TypeError","__util","user","thread","studio","queryVars","generateQueryHeaders","send","favouriteStudio","id","Error","data","studioID","ToggleFavourite","studios","nodes","some","e","search","type","term","page","amount","anime","manga","char","staff","query","toLowerCase","perPage","genres","then","GenreCollection","mediaTags","MediaTagCollection","module","exports"],"sources":["C:/Users/Ethan Liu/Desktop/repos/lightnovel-react/node_modules/anilist-node/lib/index.js"],"sourcesContent":["const activity = require(\"./activity\"),\r\n\tlists = require(\"./lists\"),\r\n\tmedia = require(\"./media\"),\r\n\tpeople = require(\"./people\"),\r\n\trecommendation = require(\"./recommendation\"),\r\n\tsearchEntry = require(\"./search\"),\r\n\tThread = require(\"./thread\"),\r\n\tUser = require(\"./user\"),\r\n\tutil = require(\"./utilities\");\r\n\r\n/**\r\n * The main class for AniList-Node\r\n * @since 1.0.0\r\n */\r\nclass AniList {\r\n\t/**\r\n\t * @constructor\r\n\t * @param {String} [accessKey] - The AniList API token. If no key is provided,\r\n\t *      the user will not be able to access private information such as\r\n\t *      the authorized user's profile (if set to private).\r\n\t * @param {InitOptions} [options] - Optional options to use when getting info from AniList\r\n\t */\r\n\tconstructor(accessKey, options = {}) {\r\n\t\tif (!accessKey) {\r\n\t\t\taccessKey = null;\r\n\t\t}\r\n\r\n\t\tif (options.timeout) {\r\n\t\t\tif (typeof options.timeout !== \"number\") throw new TypeError(\"ERROR: 'options.timeout' should be a number\");\r\n\t\t} else {\r\n\t\t\toptions.timeout = 15000;\r\n\t\t}\r\n\r\n\t\t// Import utilities for the classes.\r\n\t\tthis.__util = new util(accessKey, options);\r\n\r\n\t\t/**\r\n\t\t * @augments User\r\n\t\t * @see {@Link AniList.User}\r\n\t\t * @since 1.0.0\r\n\t\t */\r\n\t\tthis.user = new User(this.__util);\r\n\r\n\t\t/**\r\n\t\t * @augments lists\r\n\t\t * @see {@Link AniList.Lists}\r\n\t\t * @since 1.1.0\r\n\t\t */\r\n\t\tthis.lists = new lists(this.__util);\r\n\r\n\t\t/**\r\n\t\t * @augments media\r\n\t\t * @see {@Link AniList.Media}\r\n\t\t * @since 1.0.0\r\n\t\t */\r\n\t\tthis.media = new media(this.__util);\r\n\r\n\t\t/**\r\n\t\t * @augments people\r\n\t\t * @see {@Link AniList.People}\r\n\t\t * @since 1.0.0\r\n\t\t */\r\n\t\tthis.people = new people(this.__util);\r\n\r\n\t\t/**\r\n\t\t * @augments Activity\r\n\t\t * @see {@Link AniList.Activity}\r\n\t\t * @since 1.7.0\r\n\t\t */\r\n\t\tthis.activity = new activity(this.__util);\r\n\r\n\t\t/**\r\n\t\t * @augments Search\r\n\t\t * @see {@Link AniList.Search}\r\n\t\t * @since 1.7.0\r\n\t\t */\r\n\t\tthis.searchEntry = new searchEntry(this.__util);\r\n\r\n\t\t/**\r\n\t\t * @augments Recommendation\r\n\t\t * @see {@Link AniList.Recommendation}\r\n\t\t * @since 1.8.0\r\n\t\t */\r\n\t\tthis.recommendation = new recommendation(this.__util);\r\n\r\n\t\t/**\r\n\t\t * @augments Thread\r\n\t\t * @see {@Link AniList.Thread}\r\n\t\t * @since 1.11.0\r\n\t\t */\r\n\t\tthis.thread = new Thread(this.__util);\r\n\t}\r\n\r\n\t/**\r\n\t * Grabs data on a studio\r\n\t * @param {String | Number} studio - The studio ID or name on AniList.\r\n\t * @return { StudioEntry }\r\n\t * @since 1.0.0\r\n\t */\r\n\tstudio(studio) {\r\n\t\tconst queryVars = this.__util.generateQueryHeaders(\"Studio\", studio);\r\n\r\n\t\treturn this.__util.send(\r\n\t\t\tqueryVars[1] +\r\n\t\t\t\t`id name isAnimationStudio siteUrl isFavourite favourites \r\n            media { nodes { id title { romaji english native userPreferred } } } } }`,\r\n\t\t\tqueryVars[0]\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * [Requires Login] Favourite/Unfavourite a studio\r\n\t * @param {Number} id - Required. The ID tied to the AniList entry.\r\n\t * @returns {Boolean} Returns true if added, false otherwise.\r\n\t * @since 1.12.0\r\n\t */\r\n\tasync favouriteStudio(id) {\r\n\t\tif (!id || typeof id !== \"number\") {\r\n\t\t\tthrow new Error(\"AniList ID is not provided!\");\r\n\t\t}\r\n\r\n\t\tconst data = await this.util.send(\r\n\t\t\t`mutation ($studioID: Int) {\r\n\t\t\t\tToggleFavourite(studioId: $studioID) {\r\n\t\t\t\t\tstudios (page: 1, perPage: 25) {\r\n\t\t\t\t\tnodes { id }\r\n\t\t\t} } }`,\r\n\t\t\t{ studioID: id }\r\n\t\t);\r\n\r\n\t\treturn data.ToggleFavourite.studios.nodes.some((e) => {\r\n\t\t\tif (e.id === id) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Searches AniList based on a specific term.\r\n\t * @param {String} type - Required. Either anime, manga, character, staff, studio, or user.\r\n\t * @param {String} term - Required. The term to lookup. (ie: \"Honzuki no Gekokujou\" or \"Butterstroke\")\r\n\t * @param {Number} page - Which page of the results to look at. Will default to 1 if not provided.\r\n\t * @param {Number} amount - The amount of results per page. AniList will cap this at 25 and function will default to 5 if not provided.\r\n\t * @return { SearchEntry }\r\n\t * @since 1.0.0\r\n\t * @deprecated Please use {@link AniList.Search} class via `AniList.searchEntry` for updated searching. {@link AniList.Search} will replace\r\n\t * this function in the next major update (v2.0.0).\r\n\t */\r\n\tsearch(type, term, page = 1, amount = 5) {\r\n\t\tif (!type) {\r\n\t\t\tthrow new Error(\"Type of search not defined!\");\r\n\t\t} else if (!term) {\r\n\t\t\tthrow new Error(\"Search term was not provided!\");\r\n\t\t}\r\n\r\n\t\t//Validate all type conditions.\r\n\t\tif (typeof type !== \"string\") {\r\n\t\t\tthrow new Error(\"Type is not a string.\");\r\n\t\t}\r\n\t\tif (typeof term !== \"string\") {\r\n\t\t\tthrow new Error(\"Term is not a string\");\r\n\t\t}\r\n\t\tif (typeof page !== \"number\") {\r\n\t\t\tthrow new Error(\"Page number is not a number\");\r\n\t\t}\r\n\t\tif (typeof amount !== \"number\") {\r\n\t\t\tthrow new Error(\"Amount is not a number\");\r\n\t\t}\r\n\r\n\t\tconst search = {\r\n\t\t\tanime: \"media (type: ANIME, search: $search) { id title { romaji english native userPreferred } }\",\r\n\t\t\tmanga: \"media (type: MANGA, search: $search) { id title { romaji english native userPreferred } }\",\r\n\t\t\tchar: \"characters (search: $search) { id name { english: full } }\",\r\n\t\t\tstaff: \"staff (search: $search) { id name { english: full } }\",\r\n\t\t\tstudio: \"studios (search: $search) { id name }\",\r\n\t\t\tuser: \"users (search: $search) { id name }\"\r\n\t\t};\r\n\r\n\t\tlet query = search[type.toLowerCase()];\r\n\t\tif (!query) {\r\n\t\t\tthrow new Error(\"Type not supported.\");\r\n\t\t}\r\n\r\n\t\treturn this.__util.send(\r\n\t\t\t`query ($page: Int, $perPage: Int, $search: String) {\r\n        Page (page: $page, perPage: $perPage) { pageInfo { total currentPage lastPage hasNextPage perPage } ${query} } }`,\r\n\t\t\t{ search: term, page: page, perPage: amount }\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * Grabs all possible genres\r\n\t * @return { String[] }\r\n\t * @since 1.12.0\r\n\t */\r\n\tgenres() {\r\n\t\treturn this.__util.send(\"query { GenreCollection }\", null).then((data) => {\r\n\t\t\treturn data.GenreCollection;\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Grabs all possible media tags\r\n\t * @return { MediaTag[] }\r\n\t * @since 1.12.0\r\n\t */\r\n\tmediaTags() {\r\n\t\treturn this.__util\r\n\t\t\t.send(\r\n\t\t\t\t`query { MediaTagCollection {\r\n\t\t\t\tid name description category isAdult\r\n\t\t\t} }`,\r\n\t\t\t\tnull\r\n\t\t\t)\r\n\t\t\t.then((data) => {\r\n\t\t\t\treturn data.MediaTagCollection;\r\n\t\t\t});\r\n\t}\r\n}\r\n\r\nmodule.exports = AniList;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}