{"ast":null,"code":"/**\r\n * Access AniList's media data.\r\n * @since 1.0.0\r\n * @memberof AniList\r\n */\nclass Media {\n  /**\r\n   * @description This constructor is meant for internal use and is apart of initializing. You cannot access this\r\n   * through the AniList class and are not expect to.\r\n   * @param { Utilities } utilities - The AniList Utilities class.\r\n   * @hideconstructor\r\n   */\n  constructor(utilities) {\n    this.util = utilities;\n  }\n\n  /**\r\n   * Fetch an anime entry by its AniList ID.\r\n   * @param { Number } id - Required. The ID tied to the AniList entry.\r\n   * @returns { AnimeEntry }\r\n   * @since 1.0.0\r\n   */\n  anime(id) {\n    if (!id) {\n      throw new Error(\"Anime id is not provided!\");\n    }\n    if (typeof id !== \"number\") {\n      throw new Error(\"Term provided is not a number!\");\n    }\n    return this.util.send(`query ($id: Int) { Media (id: $id, type: ANIME) { id idMal title { romaji english native userPreferred } \n            format status episodes description startDate { year month day } endDate { year month day }\n            season seasonYear duration countryOfOrigin isLicensed source hashtag trailer { id site }\n            updatedAt coverImage { large:extraLarge medium:large small:medium color }\n            bannerImage genres synonyms averageScore meanScore favourites\n            popularity trending tags { id name isMediaSpoiler } relations { nodes { id title { english native romaji userPreferred } type } } \n            characters { nodes { id name { english: full } } } staff { nodes { id name { english: full } } } studios { nodes { id name isAnimationStudio } } \n            isFavourite isAdult isLocked nextAiringEpisode { timeUntilAiring airingAt episode } airingSchedule { nodes { airingAt timeUntilAiring episode } }\n            trends { nodes { date trending popularity inProgress } } externalLinks { url }\n            streamingEpisodes { title thumbnail url site } rankings { rank type context year season } mediaListEntry { id status }\n            reviews { nodes { id score summary body } } siteUrl autoCreateForumThread modNotes \n            stats { scoreDistribution { score amount } statusDistribution { status amount } }\n            isRecommendationBlocked recommendations { nodes { mediaRecommendation { id title { romaji english native userPreferred } type } } } } }`, {\n      id: id\n    });\n  }\n\n  /**\r\n   * [Requires Login] Favourite/Unfavourite an anime\r\n   * @param {Number} id - Required. The ID tied to the AniList entry.\r\n   * @returns {Boolean} Returns true if added, false otherwise.\r\n   * @since 1.12.0\r\n   */\n  async favouriteAnime(id) {\n    if (!id || typeof id !== \"number\") {\n      throw new Error(\"AniList ID is not provided!\");\n    }\n    const data = await this.util.send(`mutation ($mediaID: Int) {\n\t\t\t\tToggleFavourite(animeId: $mediaID) {\n\t\t\t\t\tanime (page: 1, perPage: 25) {\n\t\t\t\t\tnodes { id }\n\t\t\t} } }`, {\n      mediaID: id\n    });\n    return data.ToggleFavourite.anime.nodes.some(e => {\n      if (e.id === id) {\n        return true;\n      }\n    });\n  }\n\n  /**\r\n   * Fetch a manga entry by its AniList ID.\r\n   * @param { Number } id - Required. The ID tied to the AniList entry.\r\n   * @returns { MangaEntry }\r\n   * @since 1.0.0\r\n   */\n  manga(id) {\n    if (!id) {\n      throw new Error(\"Manga id is not provided!\");\n    }\n    if (typeof id !== \"number\") {\n      throw new Error(\"Term provided is not a number!\");\n    }\n    return this.util.send(`query ($id: Int) { Media (id: $id, type: MANGA) { id idMal title { romaji english native userPreferred }\n            description format status startDate { year month day } endDate { year month day } chapters volumes countryOfOrigin isLicensed updatedAt\n            coverImage { large:extraLarge medium:large small:medium color } bannerImage genres synonyms averageScore meanScore siteUrl autoCreateForumThread modNotes\n            popularity trending tags { id name isMediaSpoiler } relations { nodes { id title { english native romaji userPreferred } type } }\n            characters { nodes { id name { english: full } } } staff { nodes { id name { english: full } } } isFavourite isAdult isLocked\n            trends { nodes { date trending popularity inProgress } } externalLinks { url } rankings { rank type context year season } \n            mediaListEntry { id status } reviews { nodes { id score summary body } } \n            stats { scoreDistribution { score amount } statusDistribution { status amount } } favourites\n            isRecommendationBlocked recommendations { nodes { mediaRecommendation { id title { romaji english native userPreferred } type } } } } }`, {\n      id: id\n    });\n  }\n\n  /**\r\n   * [Requires Login] Favourite/Unfavourite a manga\r\n   * @param {Number} id - Required. The ID tied to the AniList entry.\r\n   * @returns {Boolean} Returns true if added, false otherwise.\r\n   * @since 1.12.0\r\n   */\n  async favouriteManga(id) {\n    if (!id || typeof id !== \"number\") {\n      throw new Error(\"AniList ID is not provided!\");\n    }\n    const data = await this.util.send(`mutation ($mediaID: Int) {\n\t\t\t\tToggleFavourite(mangaId: $mediaID) {\n\t\t\t\t\tmanga (page: 1, perPage: 25) {\n\t\t\t\t\tnodes { id }\n\t\t\t} } }`, {\n      mediaID: id\n    });\n    return data.ToggleFavourite.manga.nodes.some(e => {\n      if (e.id === id) {\n        return true;\n      }\n    });\n  }\n}\nmodule.exports = Media;","map":{"version":3,"names":["Media","constructor","utilities","util","anime","id","Error","send","favouriteAnime","data","mediaID","ToggleFavourite","nodes","some","e","manga","favouriteManga","module","exports"],"sources":["C:/Users/Ethan Liu/Desktop/repos/lightnovel-react/node_modules/anilist-node/lib/media.js"],"sourcesContent":["/**\r\n * Access AniList's media data.\r\n * @since 1.0.0\r\n * @memberof AniList\r\n */\r\nclass Media {\r\n\t/**\r\n\t * @description This constructor is meant for internal use and is apart of initializing. You cannot access this\r\n\t * through the AniList class and are not expect to.\r\n\t * @param { Utilities } utilities - The AniList Utilities class.\r\n\t * @hideconstructor\r\n\t */\r\n\tconstructor(utilities) {\r\n\t\tthis.util = utilities;\r\n\t}\r\n\r\n\t/**\r\n\t * Fetch an anime entry by its AniList ID.\r\n\t * @param { Number } id - Required. The ID tied to the AniList entry.\r\n\t * @returns { AnimeEntry }\r\n\t * @since 1.0.0\r\n\t */\r\n\tanime(id) {\r\n\t\tif (!id) {\r\n\t\t\tthrow new Error(\"Anime id is not provided!\");\r\n\t\t}\r\n\t\tif (typeof id !== \"number\") {\r\n\t\t\tthrow new Error(\"Term provided is not a number!\");\r\n\t\t}\r\n\r\n\t\treturn this.util.send(\r\n\t\t\t`query ($id: Int) { Media (id: $id, type: ANIME) { id idMal title { romaji english native userPreferred } \r\n            format status episodes description startDate { year month day } endDate { year month day }\r\n            season seasonYear duration countryOfOrigin isLicensed source hashtag trailer { id site }\r\n            updatedAt coverImage { large:extraLarge medium:large small:medium color }\r\n            bannerImage genres synonyms averageScore meanScore favourites\r\n            popularity trending tags { id name isMediaSpoiler } relations { nodes { id title { english native romaji userPreferred } type } } \r\n            characters { nodes { id name { english: full } } } staff { nodes { id name { english: full } } } studios { nodes { id name isAnimationStudio } } \r\n            isFavourite isAdult isLocked nextAiringEpisode { timeUntilAiring airingAt episode } airingSchedule { nodes { airingAt timeUntilAiring episode } }\r\n            trends { nodes { date trending popularity inProgress } } externalLinks { url }\r\n            streamingEpisodes { title thumbnail url site } rankings { rank type context year season } mediaListEntry { id status }\r\n            reviews { nodes { id score summary body } } siteUrl autoCreateForumThread modNotes \r\n            stats { scoreDistribution { score amount } statusDistribution { status amount } }\r\n            isRecommendationBlocked recommendations { nodes { mediaRecommendation { id title { romaji english native userPreferred } type } } } } }`,\r\n\t\t\t{ id: id }\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * [Requires Login] Favourite/Unfavourite an anime\r\n\t * @param {Number} id - Required. The ID tied to the AniList entry.\r\n\t * @returns {Boolean} Returns true if added, false otherwise.\r\n\t * @since 1.12.0\r\n\t */\r\n\tasync favouriteAnime(id) {\r\n\t\tif (!id || typeof id !== \"number\") {\r\n\t\t\tthrow new Error(\"AniList ID is not provided!\");\r\n\t\t}\r\n\r\n\t\tconst data = await this.util.send(\r\n\t\t\t`mutation ($mediaID: Int) {\r\n\t\t\t\tToggleFavourite(animeId: $mediaID) {\r\n\t\t\t\t\tanime (page: 1, perPage: 25) {\r\n\t\t\t\t\tnodes { id }\r\n\t\t\t} } }`,\r\n\t\t\t{ mediaID: id }\r\n\t\t);\r\n\r\n\t\treturn data.ToggleFavourite.anime.nodes.some((e) => {\r\n\t\t\tif (e.id === id) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Fetch a manga entry by its AniList ID.\r\n\t * @param { Number } id - Required. The ID tied to the AniList entry.\r\n\t * @returns { MangaEntry }\r\n\t * @since 1.0.0\r\n\t */\r\n\tmanga(id) {\r\n\t\tif (!id) {\r\n\t\t\tthrow new Error(\"Manga id is not provided!\");\r\n\t\t}\r\n\t\tif (typeof id !== \"number\") {\r\n\t\t\tthrow new Error(\"Term provided is not a number!\");\r\n\t\t}\r\n\r\n\t\treturn this.util.send(\r\n\t\t\t`query ($id: Int) { Media (id: $id, type: MANGA) { id idMal title { romaji english native userPreferred }\r\n            description format status startDate { year month day } endDate { year month day } chapters volumes countryOfOrigin isLicensed updatedAt\r\n            coverImage { large:extraLarge medium:large small:medium color } bannerImage genres synonyms averageScore meanScore siteUrl autoCreateForumThread modNotes\r\n            popularity trending tags { id name isMediaSpoiler } relations { nodes { id title { english native romaji userPreferred } type } }\r\n            characters { nodes { id name { english: full } } } staff { nodes { id name { english: full } } } isFavourite isAdult isLocked\r\n            trends { nodes { date trending popularity inProgress } } externalLinks { url } rankings { rank type context year season } \r\n            mediaListEntry { id status } reviews { nodes { id score summary body } } \r\n            stats { scoreDistribution { score amount } statusDistribution { status amount } } favourites\r\n            isRecommendationBlocked recommendations { nodes { mediaRecommendation { id title { romaji english native userPreferred } type } } } } }`,\r\n\t\t\t{ id: id }\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * [Requires Login] Favourite/Unfavourite a manga\r\n\t * @param {Number} id - Required. The ID tied to the AniList entry.\r\n\t * @returns {Boolean} Returns true if added, false otherwise.\r\n\t * @since 1.12.0\r\n\t */\r\n\tasync favouriteManga(id) {\r\n\t\tif (!id || typeof id !== \"number\") {\r\n\t\t\tthrow new Error(\"AniList ID is not provided!\");\r\n\t\t}\r\n\r\n\t\tconst data = await this.util.send(\r\n\t\t\t`mutation ($mediaID: Int) {\r\n\t\t\t\tToggleFavourite(mangaId: $mediaID) {\r\n\t\t\t\t\tmanga (page: 1, perPage: 25) {\r\n\t\t\t\t\tnodes { id }\r\n\t\t\t} } }`,\r\n\t\t\t{ mediaID: id }\r\n\t\t);\r\n\r\n\t\treturn data.ToggleFavourite.manga.nodes.some((e) => {\r\n\t\t\tif (e.id === id) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n}\r\n\r\nmodule.exports = Media;\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA,MAAMA,KAAK,CAAC;EACX;AACD;AACA;AACA;AACA;AACA;EACCC,WAAW,CAACC,SAAS,EAAE;IACtB,IAAI,CAACC,IAAI,GAAGD,SAAS;EACtB;;EAEA;AACD;AACA;AACA;AACA;AACA;EACCE,KAAK,CAACC,EAAE,EAAE;IACT,IAAI,CAACA,EAAE,EAAE;MACR,MAAM,IAAIC,KAAK,CAAC,2BAA2B,CAAC;IAC7C;IACA,IAAI,OAAOD,EAAE,KAAK,QAAQ,EAAE;MAC3B,MAAM,IAAIC,KAAK,CAAC,gCAAgC,CAAC;IAClD;IAEA,OAAO,IAAI,CAACH,IAAI,CAACI,IAAI,CACnB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oJAAoJ,EACjJ;MAAEF,EAAE,EAAEA;IAAG,CAAC,CACV;EACF;;EAEA;AACD;AACA;AACA;AACA;AACA;EACC,MAAMG,cAAc,CAACH,EAAE,EAAE;IACxB,IAAI,CAACA,EAAE,IAAI,OAAOA,EAAE,KAAK,QAAQ,EAAE;MAClC,MAAM,IAAIC,KAAK,CAAC,6BAA6B,CAAC;IAC/C;IAEA,MAAMG,IAAI,GAAG,MAAM,IAAI,CAACN,IAAI,CAACI,IAAI,CAC/B;AACJ;AACA;AACA;AACA,SAAS,EACN;MAAEG,OAAO,EAAEL;IAAG,CAAC,CACf;IAED,OAAOI,IAAI,CAACE,eAAe,CAACP,KAAK,CAACQ,KAAK,CAACC,IAAI,CAAEC,CAAC,IAAK;MACnD,IAAIA,CAAC,CAACT,EAAE,KAAKA,EAAE,EAAE;QAChB,OAAO,IAAI;MACZ;IACD,CAAC,CAAC;EACH;;EAEA;AACD;AACA;AACA;AACA;AACA;EACCU,KAAK,CAACV,EAAE,EAAE;IACT,IAAI,CAACA,EAAE,EAAE;MACR,MAAM,IAAIC,KAAK,CAAC,2BAA2B,CAAC;IAC7C;IACA,IAAI,OAAOD,EAAE,KAAK,QAAQ,EAAE;MAC3B,MAAM,IAAIC,KAAK,CAAC,gCAAgC,CAAC;IAClD;IAEA,OAAO,IAAI,CAACH,IAAI,CAACI,IAAI,CACnB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oJAAoJ,EACjJ;MAAEF,EAAE,EAAEA;IAAG,CAAC,CACV;EACF;;EAEA;AACD;AACA;AACA;AACA;AACA;EACC,MAAMW,cAAc,CAACX,EAAE,EAAE;IACxB,IAAI,CAACA,EAAE,IAAI,OAAOA,EAAE,KAAK,QAAQ,EAAE;MAClC,MAAM,IAAIC,KAAK,CAAC,6BAA6B,CAAC;IAC/C;IAEA,MAAMG,IAAI,GAAG,MAAM,IAAI,CAACN,IAAI,CAACI,IAAI,CAC/B;AACJ;AACA;AACA;AACA,SAAS,EACN;MAAEG,OAAO,EAAEL;IAAG,CAAC,CACf;IAED,OAAOI,IAAI,CAACE,eAAe,CAACI,KAAK,CAACH,KAAK,CAACC,IAAI,CAAEC,CAAC,IAAK;MACnD,IAAIA,CAAC,CAACT,EAAE,KAAKA,EAAE,EAAE;QAChB,OAAO,IAAI;MACZ;IACD,CAAC,CAAC;EACH;AACD;AAEAY,MAAM,CAACC,OAAO,GAAGlB,KAAK"},"metadata":{},"sourceType":"script","externalDependencies":[]}